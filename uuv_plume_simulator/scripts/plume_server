#!/usr/bin/env python
# Copyright (c) 2016 The UUV Simulator Authors.
# All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import rospy
from sensor_msgs.msg import PointCloud
from visualization_msgs.msg import MarkerArray
from geometry_msgs.msg import Point, TwistStamped
from uuv_plume_model import Plume
import numpy as np
from uuv_plume_msgs.srv import *


class PlumeSimulatorServer:
    """
    The plume server allows a plume entity to be created and configured in the
    on going simulation using ROS services. This class also contains timer
    callback functions to update the visual markers and plume point clouds
    that can be visualized in RViz.

    Examples
    --------

    To start this plume server, be sure that Gazebo has been initialized and
    then run::

        $ roslaunch uuv_plume_simulator start_plume_server.launch

    Check the files *scripts/set_demo_spheroid_plume* and
    *scripts/set_demo_turbulent_plume* to see examples on how to use the
    service calls to create plumes.

    .. note::

        Check the chemical particle concentration sensor plugin (*CPCROSPlugin*)
        to generate simulated sensor data for the particle concentration around
        the vehicle.
    """
    def __init__(self):
        # Plume model (to be defined by a service call)
        self._model = None

        # Current time stamp and time step
        self._t = rospy.get_time()
        self._dt = 0.0

        # Update rate for the current plume state
        self._update_rate = 5.0
        if rospy.has_param('~update_rate'):
            self._update_rate = float(rospy.get_param('~update_rate'))
            self._update_rate = max(0.05, self._update_rate)

        # Definition of service callbacks
        self._services = dict()

        # Service callback to create a static plume in the form of a
        # spheroid
        self._services['create_spheroid_plume'] = rospy.Service(
            'create_spheroid_plume',
            CreateSpheroidPlume,
            self.create_spheroid_plume)

        # Service callback to create a dynamic passive scalar turbulent plume
        self._services['create_passive_scalar_turbulent_plume'] = rospy.Service(
            'create_passive_scalar_turbulent_plume',
            CreatePassiveScalarTurbulentPlume,
            self.create_passive_scalar_turbulent_plume)

        # Service callback to configure the bounding box limiting the plume
        # source and particles
        self._services['set_plume_limits'] = rospy.Service(
            'set_plume_limits',
            SetPlumeLimits,
            self.set_plume_limits)

        # Service callback to change the maximum number of particles to be
        # generated by a single plume and, in the case of the dynamic plume,
        # the maximum number of particles generated at each iteration
        self._services['set_plume_config'] = rospy.Service(
            'set_plume_config',
            SetPlumeConfiguration,
            self.set_plume_configuration)

        # Service callback to return general plume configuration parameters,
        # such as maximum number of particles, model name, etc.
        self._services['get_plume_config'] = rospy.Service(
            'get_plume_config',
            GetPlumeConfiguration,
            self.get_plume_configuration)

        # Service callback to the delete the plume model, after this is called
        # the output plume point cloud will be empty
        self._services['delete_plume'] = rospy.Service(
            'delete_plume',
            DeletePlume,
            self.delete_plume)

        # Service callback to set the position of the plume source
        self._services['set_plume_source_position'] = rospy.Service(
            'set_plume_source_position',
            SetPlumeSourcePosition,
            self.set_plume_source_position)

        # Service callback to get the position of the plume source
        self._services['get_plume_source_position'] = rospy.Service(
            'get_plume_source_position',
            GetPlumeSourcePosition,
            self.get_plume_source_position)

        # Publisher for the plume visual markers
        self._plume_marker_publisher = rospy.Publisher(
            'markers',
            MarkerArray,
            queue_size=1)

        # Publisher for the plume particles point cloud
        self._plume_point_cloud_publisher = rospy.Publisher(
            'particles',
            PointCloud,
            queue_size=1)

        # Subscriber to the current velocity
        self._current_vel_subscriber = rospy.Subscriber(
            'current_vel',
            TwistStamped,
            self.current_vel_callback)

        # Timer called to update both the particle point cloud and visual
        # markers
        self._update_plume_timer = rospy.Timer(
            rospy.Duration(1 / self._update_rate),
            self.update_plume)

    def current_vel_callback(self, msg):
        """
        Subscriber callback function for the current velocity vector update.
        """
        if self._model is None:
            return

        self._model.update_current_vel([msg.twist.linear.x,
                                        msg.twist.linear.y,
                                        msg.twist.linear.z])

    def delete_plume(self, request):
        """
        Service function callback to delete the plume model. All markers and
        point cloud will be published with empty topics.
        """
        if self._model is not None:
            del self._model
        self._model = None
        return DeletePlumeResponse(True)

    def set_plume_source_position(self, request):
        """
        Service function callback that sets a new position for the plume
        source wrt the ENU frame
        """
        if self._model is None:
            return SetPlumeSourcePositionResponse(False)
        else:
            self._model.source_pos = \
                [request.source.x, request.source.y, request.source.z]
            return SetPlumeSourcePositionResponse(True)

    def get_plume_source_position(self, request):
        """
        Service function callback that returns the position wrt to the ENU
        frame for the plume source.
        """
        if self._model is None:
            return GetPlumeSourcePositionResponse(Point(-1, -1, -1))
        else:
            return GetPlumeSourcePositionResponse(
                Point(self._model.source_pos[0],
                      self._model.source_pos[1],
                      self._model.source_pos[2]))

    def get_plume_configuration(self, request):
        """
        Service function callback to return the configuration parameters for
        the current plume model being used.
        """
        if self._model is None:
            return GetPlumeConfigurationResponse(
                '',
                0,
                0,
                Point(0, 0, 0),
                0, 0, 0, 0, 0, 0)
        else:
            return GetPlumeConfigurationResponse(
                self._model.LABEL,
                self._model.n_points,
                (0 if self._model.LABEL == 'spheroid' else \
                    self._model.max_particles_per_iter),
                Point(self._model.source_pos[0],
                      self._model.source_pos[1],
                      self._model.source_pos[2]),
                self._model.x_lim[0],
                self._model.x_lim[1],
                self._model.y_lim[0],
                self._model.y_lim[1],
                self._model.z_lim[0],
                self._model.z_lim[1])

    def set_plume_configuration(self, request):
        """
        Service function callback to set general plume configuration parameters.
        """
        if self._model is None:
            print 'No plume model has been created'
            return SetPlumeConfigurationResponse(False)
        try:
            if not self._model.set_n_points(request.n_points):
                return SetPlumeConfigurationRequest(False)

            print 'Change in the plume configuration:'
            print '\t- # particles=', request.n_points

            if request.max_particles_per_iter > 0 and self._model.LABEL == 'passive_scalar_turbulence':
                if not self._model.set_max_particles_per_iter(request.max_particles_per_iter):
                    return SetPlumeConfigurationRequest(False)
                    print '\t- Max. number of particles per iteration=', request.max_particles_per_iter
            return SetPlumeConfigurationResponse(True)
        except Exception, e:
            print 'Error setting the plume configuration, message=' + str(e)
            return SetPlumeConfigurationResponse(False)

    def set_plume_limits(self, request):
        """
        Service function callback to set the plume bounding box limits.
        """
        if self._model is None:
            print 'No plume model has been created'
            return SetPlumeLimitsResponse(False)

        try:
            self._model.set_x_lim(request.x_min, request.x_max)
            self._model.set_y_lim(request.y_min, request.y_max)
            self._model.set_z_lim(request.z_min, request.z_max)
            return SetPlumeLimitsResponse(True)
        except Exception, e:
            print 'Error setting the plume limits, message=' + str(e)
            return SetPlumeLimitsResponse(False)

    def create_spheroid_plume(self, request):
        """
        Service function callback to create a static spheroid plume model.
        """
        if request.a <= 0 or request.c <= 0:
            return CreateSpheroidPlumeResponse(False)
        if request.n_points <= 0:
            return CreateSpheroidPlumeResponse(False)

        try:
            q = np.array([request.orientation.x,
                          request.orientation.y,
                          request.orientation.z,
                          request.orientation.w])
            self._model = Plume.create_plume_model(
                'spheroid',
                request.a,
                request.c,
                q,
                [request.source.x, request.source.y, request.source.z],
                request.n_points,
                rospy.get_time())

            self._model.set_x_lim(request.x_min, request.x_max)
            self._model.set_y_lim(request.y_min, request.y_max)
            self._model.set_z_lim(request.z_min, request.z_max)
            return CreateSpheroidPlumeResponse(True)
        except Exception, e:
            print 'Error, message=' + str(e)
            self._model = None
            return CreateSpheroidPlumeResponse(False)

    def create_passive_scalar_turbulent_plume(self, request):
        """
        Service function callback to create a passive scalar turbulent plume
        model.
        """
        try:
            self._model = Plume.create_plume_model(
                'passive_scalar_turbulence',
                [request.turbulent_diffusion_coefficients.x,
                 request.turbulent_diffusion_coefficients.y,
                 request.turbulent_diffusion_coefficients.z],
                request.buoyancy_flux,
                request.stability_param,
                [request.source.x, request.source.y, request.source.z],
                request.n_points,
                rospy.get_time(),
                request.max_particules_per_iter)

            self._model.set_x_lim(request.x_min, request.x_max)
            self._model.set_y_lim(request.y_min, request.y_max)
            self._model.set_z_lim(request.z_min, request.z_max)
            return CreatePassiveScalarTurbulentPlumeResponse(True)
        except Exception, e:
            print 'Error, message=' + str(e)
            self._model = None
            return CreatePassiveScalarTurbulentPlumeResponse(False)

    def update_plume(self, event):
        """
        Callback function for the plume timer which contains the update for
        the plume particle point cloud and visual markers for RViz.
        """
        self._dt = rospy.get_time() - self._t

        if self._dt <= 0.0:
            return True

        if self._model is None:
            marker = MarkerArray()
            self._plume_marker_publisher.publish(marker)
            pc_msg = PointCloud()
            pc_msg.header.stamp = rospy.Time.now()
            pc_msg.header.frame_id = 'world'
            self._plume_point_cloud_publisher.publish(pc_msg)
            return True

        if not self._model.update(rospy.get_time()):
            return True

        marker = self._model.get_markers()

        if marker is not None:
            self._plume_marker_publisher.publish(marker)

        pc_msg = self._model.get_point_cloud_as_msg()
        if pc_msg is not None:
            self._plume_point_cloud_publisher.publish(pc_msg)

        return True


if __name__ == '__main__':
    print 'Plume simulator server'
    rospy.init_node('plume_simulator_server')

    try:
        pb = PlumeSimulatorServer()
        rospy.spin()
    except rospy.ROSInterruptException:
        print('caught exception')
